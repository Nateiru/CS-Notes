#### C++中指针和引用的区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用 sizeof 看一个指针的大小为4字节（32位，如果要是64位的话指针为8字节），而引用则是被引用对象的大小；
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
5. 指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变；
6. 指针可以是多级，而引用没有分级；
7. 如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄漏。

**引用占用内存空间吗？** 对引用取地址，其实是取的引用所对应的内存空间的地址。这个现象让人觉得引用好像并非一个实体。但是引用是占用内存空间的，而且其占用的内存和指针一样，因为引用的内部实现就是通过指针来完成的。

#### 四种类型转换

- `static_cast`：用于良性转换，一般不会导致意外发生，风险很低。常用于基本类型转换到 void，转换父类指针到子类不安全；

- `const_cast`：一般用于去掉const属性以及volatile，但是如果原来他就是**常量去掉之后千万不要修改**；比如你手里有一个常量指针引用，但是函数接口是非常量指针，可能需要转换一下；成员函数声明为const，你想用this去执行一个函数，也需要用 `const_cast`；

- `dynamic_cast`：用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功；

- `reinterpret_cast`：重新解释转换是将一个指针或引用转换为另一个类型的指针或引用，通常用于底层编程，如将指针转换为整数。重新解释转换是最不安全的转换方式，可能会引发未定义行为，用于序列化网络包数据等。

#### C++中的容器了解多少

一个容器是特定类型对象的集合，在C++标准库中包含了大部分常见的容器。STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。STL 是 C++ 标准库的一部分，不用单独安装。TSL核心包括3个组件。容器(containers)，算法(algorithms)，迭代器(iterators)。除此外还有仿函数，内存配置器和配接器。

- 序列式容器（Sequence containers）：此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。
- 关联式容器（Associative containers）：此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。

对于容器，主要的操作有：容器的建立、插入元素、删除元素、查询、遍历、计算元素个数、检查元素是否为空、输出容器包含的内容。