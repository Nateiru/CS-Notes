## 文件系统

### 为什么需要文件系统？

#### 设备在应用程序之间的共享

**终端**

- 多个进程并行打印，如何保证不混乱？
  - Unicode 字符和 Escape Code 被隔断可不是闹着玩的
- 多个进程并行读，就会**发生争抢**
  - 谁抢到谁赢 (还算可以接受)
  - 后台进程会在读终端时收到 SIGTTIN (RTFM)

---

**磁盘需要支持数据的持久化**

- 程序数据
  - 可执行文件和动态链接库
  - 应用数据 (高清图片、过场动画、3D 模型……)
- 用户数据
  - 文档、下载、截图、replay……
- 系统数据
  - Manpages
  - 系统配置

------

**字节序列并不是磁盘的好抽象**

- 让所有应用共享磁盘？一个程序 bug 操作系统就没了

### 文件系统：虚拟磁盘

文件系统是一种用于在计算机系统中管理和组织文件和数据的机制。它提供了一种从用户角度来看，**文件和目录之间的层次结构**，从而让用户能够更方便地管理和存储文件。

“存储设备 (字节序列) 的虚拟化”

- 磁盘 (I/O 设备) = 一个可以读/写的字节序列
- 虚拟磁盘(文件) = 一个可以读/写的**动态**字节序列
  - 命名管理
    - 虚拟磁盘的名称、检索和遍历
  - 数据管理
    - `std::vector<char>` (随机读写/resize)

文件系统通常包括以下几个部分：

1. 目录结构：文件系统中的所有文件和目录都以树形结构组织，其中根目录是整个文件系统的起点。每个目录都可以包含其他目录和文件。
2. 文件和目录：文件系统中的文件包含了数据和元数据。数据是文件实际存储的内容，而元数据则包括了文件的名称、大小、权限、创建时间、修改时间等属性。目录则用

### 创建文件系统 mkfs

> mkfs（make filesystem）是一个用于创建文件系统的命令行工具。它的作用是**将一个空的磁盘分区格式化为特定的文件系统类型**。

mkfs 工具可以用于创建多种类型的文件系统，如ext2、ext3、ext4、FAT32、NTFS等。

```bash
mkfs.ext4 /dev/sda1
```

上面的命令将创建一个ext4文件系统在磁盘分区 /dev/sda1 上。具体来说，它将在设备/dev/sda1上创建一个新的ext4文件系统，并对其进行格式化，以便在该设备上存储文件和数据。

mkfs命令还可以接受一些可选参数，用于设置文件系统的一些属性，例如inode大小、块大小、文件系统标签等。

> 使用mkfs工具时，格式化操作会将磁盘分区上的所有数据完全清除。

### 挂载 mount

> 挂载（Mount）是指将一个**文件系统**添加到Linux文件系统层次结构（文件系统树）中的过程，它是将**物理设备或网络存储**映射到文件系统的重要步骤。当一个文件系统被挂载到某个目录时，该目录中的内容就会被隐藏，并被新挂载的文件系统所覆盖。

```c
int mount(const char *source, const char *target,
          const char *filesystemtype, unsigned long mountflags,
          const void *data);
```

**隐藏是什么意思，能举个例子吗？**

挂载操作会将设备的文件系统与挂载点进行绑定，使得挂载点成为该文件系统的根目录，而文件系统中的文件和目录则会以挂载点为起点进行展示。因此，挂载操作会覆盖掉原本存在于挂载点中的目录结构，从而导致挂载点中原本存在的文件和目录被隐藏起来，直到设备被从挂载点卸载之后才会重新显示出来，简洁的说，被隐藏也就是也就是在该目录下无法访问这些文件和目录，直到设备从该挂载点卸载之后才能重新显示。

**为什么需要mount操作？**

在Linux中，所有的文件和目录都是在文件系统中组织的。通过挂载一个文件系统，可以使其在Linux文件系统层次结构中变得可访问，从而可以像访问本地文件一样访问这些文件。例如，可以将一个USB闪存驱动器挂载到/mnt目录下，然后就可以在/mnt目录下访问闪存驱动器中的文件了。

此外，Linux中的挂载操作还可以用于挂载网络存储设备，如NFS、CIFS等。这些网络存储设备可以通过网络访问，但是在Linux中必须将其挂载到文件系统中才能访问其中的文件。

**假如有我电脑有一块磁盘，如果不mount是不是就不能使用？**

是的，如果不对磁盘进行挂载操作，就不能在Linux文件系统中访问磁盘中的文件和目录。

当您连接一个新的磁盘到计算机上时，这个磁盘可能会被操作系统检测到，但是它不会自动出现在Linux文件系统中。为了让这个磁盘在Linux中可用，您需要执行挂载操作，将磁盘挂载到文件系统中的一个目录上。这样就可以访问磁盘中的文件和目录了。

举个例子，假设您的计算机上连接了一个USB闪存驱动器，它被识别为/dev/sdb。如果您想要访问驱动器中的文件和目录，您需要先在Linux中创建一个目录，例如/mnt/usb，然后使用以下命令将USB驱动器挂载到这个目录：

```bash
# mount [-t 文件系统类型] [-o 选项] 设备名 挂载点
sudo mount /dev/sdb /mnt/usb
```

这将把USB驱动器挂载到/mnt/usb目录，使得您可以在/mnt/usb目录下访问驱动器中的文件和目录。

需要注意的是，当您不再需要访问磁盘中的文件时，应该先卸载磁盘，然后再从计算机上移除磁盘。这可以通过使用umount命令来完成，例如：

```bash
sudo umount /mnt/usb
```

这将卸载/mnt/usb目录中挂载的USB驱动器，使得您可以安全地移除驱动器。如果您直接拔掉USB驱动器而没有先卸载它，可能会导致数据损坏或丢失。

> Linux操作系统通常会**自动检测和挂载已连接的磁盘**，例如硬盘、USB驱动器、SD卡等存储设备。当Linux系统启动时，它会读取/etc/fstab文件中的配置信息，并根据配置信息自动挂载已连接的磁盘。
>
> /etc/fstab文件是Linux系统中用于配置文件系统挂载的文件。它包含了每个文件系统的配置信息，例如设备名称、挂载点、文件系统类型、挂载选项等。在启动过程中，Linux系统会读取/etc/fstab文件，并根据其中的配置信息挂载文件系统。
>
> 当您连接一个新的存储设备时，Linux系统会自动检测到该设备，并尝试将其挂载到文件系统中。如果该设备在/etc/fstab文件中已经有了配置信息，那么Linux系统会根据该配置信息进行挂载。如果没有配置信息，Linux系统可能会提示您输入一些挂载选项或者默认使用一些选项进行挂载。

因此也就对于一块磁盘，操作系统会检测到该设备，但是如果想要该设备能够使用，还需要将其挂载到文件系统上，**现代的Linux系统通常会在您插入U盘等可移动存储设备后自动将其挂载到文件系统中**。这是通过udev守护进程和自动挂载系统实现的。

> 当您插入一个U盘时，udev守护进程会自动检测到该设备，并执行相应的规则来加载相应的驱动程序并创建设备节点。然后，自动挂载系统会检测到新设备，并尝试自动将其挂载到文件系统中。如果文件系统类型已知，并且该设备上的文件系统没有损坏，自动挂载系统会使用相应的挂载选项自动将其挂载到合适的挂载点上。
>
> 当您不再需要使用U盘时，可以使用umount命令将其从文件系统中卸载，并安全地拔出设备。注意，**拔出U盘之前，必须先将其从文件系统中卸载，否则可能会导致文件系统损坏或数据丢失**。

## 在Linux上创建多个用户

### 创建用户

在 Linux 上创建多个用户可以使用 `useradd` 命令或者 `adduser` 命令，其中 `adduser` 命令是 `useradd` 命令的一个高级封装。

下面以 `adduser` 命令为例，介绍如何在 Linux 上创建多个用户：

1. 使用 root 用户登录 Linux 系统；
2. 执行以下命令创建用户：

```bash
sudo adduser user1    # 创建一个名为 user1 的用户
sudo adduser user2    # 创建一个名为 user2 的用户
```

执行命令后，系统会提示输入密码、确认信息等，按照提示完成输入即可。

3. 创建用户后，可以使用以下命令切换到不同的用户账号：

```bash
su - user1    # 切换到 user1 账号
su - user2    # 切换到 user2 账号
```

切换到用户账号后，可以执行命令来测试用户是否正常工作。

需要注意的是，Linux 中的用户账号通常包含用户名、用户组、用户 ID、主目录等信息。在使用 `adduser` 命令创建用户时，可以通过指定不同的参数来自定义用户账号的配置。例如，可以使用 `-g` 参数指定用户组，使用 `-d` 参数指定主目录等。

```bash
sudo adduser --ingroup developers --home /home/user1 user1
```

在 Linux 上创建多个用户可以使用 `useradd` 命令或者 `adduser` 命令，其中 `adduser` 命令是 `useradd` 命令的一个高级封装。

下面以 `adduser` 命令为例，介绍如何在 Linux 上创建多个用户：

1. 使用 root 用户登录 Linux 系统；

2. 执行以下命令创建用户：

   ```
   bashCopy codesudo adduser user1    # 创建一个名为 user1 的用户
   sudo adduser user2    # 创建一个名为 user2 的用户
   ```

   执行命令后，系统会提示输入密码、确认信息等，按照提示完成输入即可。

3. 创建用户后，可以使用以下命令切换到不同的用户账号：

   ```
   bashCopy codesu - user1    # 切换到 user1 账号
   su - user2    # 切换到 user2 账号
   ```

   切换到用户账号后，可以执行命令来测试用户是否正常工作。

需要注意的是，Linux 中的用户账号通常包含用户名、用户组、用户 ID、主目录等信息。在使用 `adduser` 命令创建用户时，可以通过指定不同的参数来自定义用户账号的配置。例如，可以使用 `-g` 参数指定用户组，使用 `-d` 参数指定主目录等。

```
bashCopy code
sudo adduser --ingroup developers --home /home/user1 user1
```

上面的命令将创建一个用户名为 `user1`，所属用户组为 `developers`，主目录为 `/home/user1` 的用户账号。

除了使用命令行，也可以使用图形化界面工具来创建和管理用户账号，例如 GNOME 环境下的用户和群组管理器（Users and Groups）。

### 分配磁盘空间

在 Linux 中，每个用户都会分配一个默认的主目录，通常是 `/home/username` 目录，这个目录也是用户的工作目录。

用户可以在自己的主目录中创建和管理文件和文件夹，但是默认情况下，用户的主目录是没有足够的磁盘空间来存储大量数据的。

因此，在 Linux 上为用户分配磁盘空间是一个很常见的操作，通常的做法是创建一个独立的文件系统，并将其挂载到用户的主目录下。

下面是一个示例操作：

1. 创建一个独立的文件系统：

```bash
sudo mkfs -t ext4 /dev/sdb1  # 创建一个 ext4 文件系统，/dev/sdb1 是硬盘设备名称，具体根据实际情况而定
```

2. 创建一个挂载点，并将其挂载到用户的主目录下：

```bash
sudo mkdir /data/user1    # 创建一个挂载点
sudo mount /dev/sdb1 /data/user1    # 将 /dev/sdb1 挂载到 /data/user1 目录下
sudo chown user1:user1 /data/user1    # 修改挂载目录的权限，使得 user1 用户可以访问
```

上面的命令将 `/dev/sdb1` 文件系统挂载到 `/data/user1` 目录下，并将该目录的所有权赋予 `user1` 用户，使得该用户可以在 `/data/user1` 目录下创建、读取和修改文件。

3. 配置系统自动挂载：

上述操作只能保证在当前会话中 `/dev/sdb1` 文件系统会被挂载到 `/data/user1` 目录下，如果系统重新启动，挂载将丢失。为了保证挂载的持久性，可以在 `/etc/fstab` 文件中添加一条自动挂载的记录：

```bash
/dev/sdb1   /data/user1    ext4    defaults    0    0
```

这样，当系统启动时，自动挂载 `/dev/sdb1` 到 `/data/user1` 目录下。

需要注意的是，在为用户分配磁盘空间时，应该注意磁盘配额的设置，避免用户占用过多磁盘空间影响系统性能和稳定性。可以使用 `quota` 工具来实现磁盘配额的管理。

## Linux系统中通过文件系统访问一个文件

在 Linux 系统中，访问一个文件的过程大致如下：

1. 应用程序调用系统调用，请求打开指定的文件。
2. 内核检查文件名，并根据文件名找到文件所在的目录。
3. **如果该目录所在的文件系统没有被挂载，则无法访问该目录中的文件。**如果该目录所在的文件系统已经被挂载，则内核读取该文件系统的超级块（Superblock）信息，以确定该文件系统的详细信息。
4. 根据文件名和目录信息，内核在文件系统中查找指定的文件。如果找到了该文件，则内核返回一个文件描述符（File Descriptor），该文件描述符用于后续的读写操作。
5. 如果该文件所在的文件系统采用了磁盘缓存（Disk Cache），则内核将该文件的部分或全部内容读取到缓存中，以便后续读取操作能够更快地完成。
6. 应用程序通过文件描述符进行读写操作，内核根据文件描述符和文件系统中的文件位置信息进行相应的操作。
7. 如果文件被修改，则内核将该文件的修改写入到磁盘中。如果该文件所在的文件系统采用了磁盘缓存，则内核可能会将多个修改操作合并后再一次性写入磁盘，以提高性能。
8. 应用程序完成对文件的操作后，通过系统调用关闭文件描述符。

总的来说，通过文件系统访问一个文件需要多个步骤，包括文件系统的挂载、文件的查找、缓存的读取和写入等。在这个过程中，文件系统的超级块扮演了重要的角色，它记录了文件系统的各种信息，包括文件系统的大小、块大小、inode 数量等等，可以帮助内核快速定位文件系统中的文件。

---

超级块（superblock）是文件系统中的一个重要数据结构，包含了文件系统的元数据信息，如文件系统的大小、块的大小、块位图、索引节点表等。

每个文件系统只有一个超级块，存储在文件系统的固定位置。当文件系统被挂载时，操作系统会读取超级块中的信息，以便能够正确地访问文件系统中的文件和目录。如果超级块损坏，文件系统就无法被正确地挂载和访问。

在Linux系统中，使用命令“dumpe2fs”可以查看文件系统的超级块信息。通常情况下，用户不需要手动编辑或修改超级块信息。

## 系统调用：quota 和 df

### man quota

quota命令用于显示磁盘配额信息，它可以帮助管理员控制用户的磁盘使用量。使用quota命令可以查看某个用户或组的磁盘配额，以及已使用的磁盘空间和剩余可用空间等信息。管理员可以使用quota命令设置和修改磁盘配额，限制用户的磁盘使用量。

在 Linux 中，可以使用 `quota` 命令来查看用户的磁盘配额和使用情况。`quota` 命令需要在超级用户权限下运行。

以下是查看某个用户的磁盘配额和使用情况的示例：

```bash
sudo -s    # 切换到超级用户
quotacheck -avug    # 检查磁盘配额
edquota -u username    # 修改 username 用户的磁盘配额，可以设置软限制和硬限制

# 查看 username 用户的磁盘使用情况
quota -s username
```

其中，`quotacheck` 命令用于检查磁盘配额，并自动创建配额文件，`edquota` 命令用于修改用户的磁盘配额，可以设置软限制和硬限制，`quota` 命令用于查看用户的磁盘配额和使用情况。

在输出中，软限制指的是用户当前可用的磁盘空间，硬限制则是用户的最大可用磁盘空间。如果软限制达到了硬限制，用户就无法再向磁盘中写入数据。

注意：**不同的 Linux 发行版可能具有不同的磁盘配额管理工具和文件系统，具体操作可能有所不同。**

### man df

`df` 命令用于显示文件系统的磁盘使用情况，包括磁盘总容量、已用空间、可用空间等信息，但不包括磁盘配额和用户的磁盘使用情况。`df` 命令可以帮助用户了解磁盘使用情况，以便及时清理不必要的文件，释放磁盘空间。

### 配合使用的例子

可以通过`df`命令查看文件系统的使用情况，包括文件系统的总容量、已使用容量和可用容量等信息。而`quota`命令则用于查看磁盘配额的使用情况，包括每个用户或组已经使用了多少磁盘配额以及磁盘配额的限制等信息。

假设我们在Linux系统中为每个用户设置了磁盘配额，并使用了`quota`命令来查看当前配额使用情况。如果我们想要进一步了解磁盘配额使用情况对文件系统总容量的影响，我们可以使用`df`命令来查看文件系统的使用情况。具体例子如下：

```bash
$ quota -u alice
Disk quotas for user alice (uid 1001): 
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
      /dev/sda1  12000M  15000M  16000M           10000       0       0       

$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev             16G     0   16G   0% /dev
tmpfs           3.2G  2.2M  3.2G   1% /run
/dev/sda1        30G   12G   17G  41% /
tmpfs            16G   20K   16G   1% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs            16G     0   16G   0% /sys/fs/cgroup
tmpfs           3.2G  112K  3.2G   1% /run/user/1000
```

从上述例子中可以看出，用户`alice`的磁盘配额为15GB，已经使用了12GB，文件系统`/dev/sda1`总容量为30GB，已经使用了12GB，剩余17GB。可以看到`quota`命令和`df`命令提供了不同层面的信息，但两者结合起来可以更全面地了解文件系统的使用情况。

用户`alice`被分配了/dev/sda1中的15GB的空间配额，但是还有15GB的空间没有分配给该用户。这15GB的空间可能已经被分配给其他用户或者还没有被分配。

## Disk Dump

### 介绍

磁盘转储（Disk Dump），也称为内存转储或核心转储，是指将计算机内存或硬盘上的数据和程序转储到另一个媒介上以便进行分析或诊断问题的过程。磁盘转储可以用于各种用途，包括调试软件崩溃、分析计算机安全问题或还原数据。

在磁盘转储过程中，计算机内存或硬盘上的所有数据都被复制到一个文件中。这个文件通常称为转储文件或转储映像。转储文件的大小通常与内存或硬盘的大小相同，因此转储过程可能需要一段时间来完成。在生成转储文件之后，可以使用专用的工具对其进行分析，以诊断计算机出现的问题。	

磁盘转储通常被用于以下几个方面：

1. 软件崩溃调试：当软件发生崩溃时，可以使用磁盘转储来捕获软件崩溃时的状态。这有助于开发人员定位问题并修复错误。
2. 安全性分析：磁盘转储可以用于分析计算机安全事件。例如，当计算机遭受攻击时，可以使用磁盘转储来分析攻击者留下的痕迹。
3. 数据还原：当数据意外丢失时，可以使用磁盘转储来还原数据。例如，在文件损坏或误删除的情况下，可以使用磁盘转储来恢复丢失的文件。

总之，磁盘转储是一个非常有用的工具，可用于分析计算机问题、调试软件崩溃、分析安全事件或还原丢失的数据。

### man dd

**磁盘转储（Disk Dump）是通过在Unix和类Unix操作系统中使用 dd 命令实现的。**

> man **dd (Disk Dump)**——`convert and copy a file`
>
> - `if=file`： 输入文件名或设备地址，如文件、目录、挂载盘、镜像、闪存、键盘等。
> - `of=file`： 输出文件名或设备地址，如文件、硬盘、U盘、闪存、显示屏、串口等。
> - `bs=bytes`：一次读取和写入块大小，默认b=512字节。
> - `count=n` ：不是完全读取输入文件，读取前n个块大小。
> - `seek=n` ：从头截断输出文件到 n个块大小处，再在末尾写入内容。

dd命令可以读取和写入数据，也可以将数据流转换为不同的格式。以下是dd命令的一些常见用法：

1. 复制文件

```bash
dd if=/path/to/source of=/path/to/destination
```

这将从源文件中读取数据，并将其写入到目标文件中。源文件和目标文件可以是任何类型的文件。

2. 复制设备

```bash
dd if=/dev/source of=/dev/destination
```

这将从源设备中读取数据，并将其写入到目标设备中。源设备和目标设备可以是任何类型的设备，例如硬盘、U盘或光盘等。

3. 指定数据块大小

```bash
dd if=/dev/source of=/dev/destination bs=4K
```

这将从源设备中读取数据，并将其以4K的数据块大小写入到目标设备中。通过指定数据块大小，可以提高数据传输的效率。

4. 显示进度和速度

```bash
dd if=/dev/source of=/dev/destination status=progress
```

这将从源设备中读取数据，并将其写入到目标设备中。在传输过程中，将会显示传输的进度和速度信息。

5. 转换数据格式

```bash
dd if=/dev/source conv=ascii of=/path/to/destination
```

这将从源设备中读取数据，并将其转换为ASCII格式，然后写入到目标文件中。除了ASCII格式之外，还可以使用其他格式，如ebcdic、ibm、block、unblock、swab等。

6. 创建空文件

```bash
dd if=/dev/zero of=/path/to/destination bs=1M count=10
```

这将创建一个10MB大小的空文件，并将其写入到目标文件中。通过指定if参数为/dev/zero，可以向文件中写入0。

总之，dd命令用于在Linux和Unix系统中复制文件、设备和数据流，并进行格式转换和数据处理等操作。